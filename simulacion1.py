# -*- coding: utf-8 -*-
"""simulacion1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OJSVTg37GLpKDmzfCuUWfVRG7Ojh8rjX
"""

# Importando paquete de control

try:
  from control.matlab import *
except:
  !pip install control
  from control.matlab import *

# Importando PyPlot

import matplotlib.pyplot as plt

# Importando NumPy

import numpy as np

# Importando SymPy

import sympy as sp
from sympy.physics.mechanics import dynamicsymbols, init_vprinting
init_vprinting()

import sympy as sp
import numpy as np
import matplotlib.pyplot as plt

# Definiendo las variables simbólicas y constantes
b = sp.symbols('b')
a = 20 * 10**(-4)
p = 0.977
dv = 23.6
K = 4.8 * 10**(4)
tl = np.log(10**5)
ll = np.log(10**4)
limites = [1, 5]  # Limites de integración de la función

# Valores de v para iterar
v_values = [1900, 2000, 2100, 2200]

# Configuración de la figura
plt.figure(figsize=(20, 10))

# Bucle para iterar sobre los valores de v
for v in v_values:
    # Función a graficar
    y = ((v * sp.log(2)) / (sp.log(b/a) * dv)) * (sp.log(v/(p*a*sp.log(b/a))) - sp.log(K))
    y_val = sp.lambdify(b, y)(np.linspace(limites[0], limites[1], 1000))

    # Graficar cada función
    plt.plot(np.linspace(limites[0], limites[1], 1000), y_val, label=f'V={v} V')

# Añadiendo líneas horizontales
plt.axhline(y=tl, color='violet', linestyle='--', label='Límite superior (ln(10^5))')
plt.axhline(y=ll, color='blue', linestyle='--', label='Límite inferior (ln(10^4))')

# Configuraciones adicionales de la gráfica
plt.grid()
plt.legend()
plt.title("Logaritmo natural de factor de multiplicación en función de radio del cátodo y el voltaje aplicado")
plt.xlabel("Radio del cátodo b [cm]")
plt.ylabel("Logaritmo natural del factor de multiplicación")
plt.show()

import sympy as sp
import numpy as np
import matplotlib.pyplot as plt

# Tus variables y función
v = sp.symbols('v')
b = 2.42
a = 20 * 10**(-4)
p = 0.977
dv = 23.6
K = 4.8 * 10**(4)
tl = np.log(10**5)
ll = np.log(10**4)
limites = [250, 3000]  # Limites de integración de la función

# Función que deseas graficar
y = ((v * sp.log(2)) / (sp.log(b/a) * dv)) * (sp.log(v/(K*p*a*sp.log(b/a))))

# Generación de valores para la gráfica
x_val = np.linspace(limites[0], limites[1], 250)
y_val = sp.lambdify(v, y)(x_val)

# Creación de la gráfica
plt.figure(figsize=(20, 10))
plt.plot(x_val, y_val, zorder=0, label='Función real')  # Grafica la función real

# Añadiendo líneas horizontales
plt.axhline(y=tl, color='red', linestyle='--', label='Límite superior (ln(10^5))')
plt.axhline(y=ll, color='green', linestyle='--', label='Límite inferior (ln(10^4))')

plt.grid()
plt.legend()
plt.title("Logaritmo natural de factor de multiplicación en función del voltaje aplicado")
plt.xlabel("Voltaje [V]")
plt.ylabel("Logaritmo natural del factor de multiplicación")
plt.show()

c=2*np.pi*8.854*10**(-12)*0.14/(np.log(0.0242/(20 * 10**(-6))))
c

m=sp.symbols('m')
E=14.4*10**(3)
e=1.602*10**(-19)
W=26
c=10*10**(-9)
v1=E*e*sp.exp(m)/(W*c)
y_val1 = sp.lambdify(m, v1)(y_val)
# Creación de la gráfica
plt.figure(figsize=(20, 10))
plt.plot(x_val, y_val1, zorder=0, label='Función real')  # Grafica la función real



plt.grid()
plt.legend()
plt.title("Voltaje del pulso en función del voltaje de entrada")
plt.xlabel("Voltaje [V]")
plt.ylabel("Voltaje del pulso [V]")
plt.show()